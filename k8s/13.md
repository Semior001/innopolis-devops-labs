```plain
$ kubectl get pods,svc,sts,svc,pvc 
NAME                              READY   STATUS        RESTARTS       AGE
pod/app-python-0                  1/1     Running       0              5m
pod/app-python-1                  1/1     Running       0              5m

NAME                         TYPE           CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE
service/app-python           LoadBalancer   10.107.238.204   <pending>     80:31271/TCP     5m
service/kubernetes           ClusterIP      10.96.0.1        <none>        443/TCP          218d

NAME                          READY   AGE
statefulset.apps/app-python   2/2     5m

NAME                                                       STATUS   VOLUME                                    CAPACITY   ACCESS MODES   STORAGECLASS   AGE
persistentvolumeclaim/helm-app-state-volume-app-python-0   Bound    pvc-6898436b-ee85-46d4-af96-9ac3066a3abf  1Gi        RWO            standard       5m
persistentvolumeclaim/helm-app-state-volume-app-python-1   Bound    pvc-fd15d5e2-3b85-4d63-87b6-eb95bd412788  1Gi        RWO            standard       5m

$ kubectl exec app-python-0 -- cat /app/data/visits.txt
172.17.0.1
172.17.0.1
172.17.0.1
172.17.0.1
172.17.0.1
172.17.0.1
172.17.0.1

$ kubectl exec app-python-1 -- cat /app/data/visits.txt
172.17.0.1
172.17.0.1
172.17.0.1
172.17.0.1
172.17.0.1
172.17.0.1
172.17.0.1
172.17.0.1
172.17.0.1
172.17.0.1
172.17.0.1
172.17.0.1
172.17.0.1
172.17.0.1
172.17.0.1
```

Each replica are independent from the others, which means that a single replica will continue working even if other
replicas will be down.

We can start the pods in parallel by adding *podManagementPolicy: "Parallel"* to spec.

Based on [kubernetes guide on statefulset](https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#update-strategies) we can use two strategies:
- OnDelete - update will be triggered only when we delete the pod
- RollingUpdate - update will be triggered automatically

